{"version":3,"sources":["logo.svg","constants/action-types.js","actions/index.js","constants/graph.js","reducers/graph.js","reducers/algorithm.js","reducers/index.js","store/index.js","algorithms/dijkstra.js","components/ActionsBar/index.js","components/Node/index.js","components/Graph/index.js","App.js","index.js"],"names":["module","exports","CHANGE_NODE_TYPE","CLEAR_GRAPH","RESET_GRAPH","START_ALGORITHM","END_ALGORITHM","changeNodeType","node","nodeType","type","ActionTypes","clearGraph","startAlgorithm","endAlgorithm","GraphModes","Object","freeze","START","END","WALL","NodeTypes","DEFAULT","TRAVERSED","PATH","reducer","state","rows","Math","floor","window","innerHeight","columns","innerWidth","matrix","Array","map","x","currStart","row","col","currEnd","initialState","action","forEach","rowArr","arr","isRunning","rootReducer","combineReducers","graph","algorithm","store","createStore","adjacent","adjacentNodes","Set","length","add","minDistance","distance","Q","minNode","minDist","Infinity","element","sleep","ms","Promise","resolve","setTimeout","start","end","a","dispatch","rowNum","colNum","previous","reachedEnd","getState","u","delete","v","altDist","size","dijkstra","ActionsBar","mode","setMode","useDispatch","useSelector","algoRunning","className","id","name","onClick","for","defaultChecked","disabled","Node","Graph","graphMode","handleClick","useCallback","value","App","useState","setGraphMode","src","logo","alt","render","document","getElementById"],"mappings":"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","file":"static/js/main.5279bc12.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.5d5d9eef.svg\";","export const CHANGE_NODE_TYPE = \"CHANGE_NODE_TYPE\";\nexport const CLEAR_GRAPH = \"CLEAR_GRAPH\";\nexport const RESET_GRAPH = \"RESET_GRAPH\";\nexport const START_ALGORITHM = \"START_ALGORITHM\";\nexport const END_ALGORITHM = \"END_ALGORITHM\";\n","import * as ActionTypes from 'constants/action-types';\n\nexport const changeNodeType = (node, nodeType) => ({\n  type: ActionTypes.CHANGE_NODE_TYPE,\n  node,\n  nodeType,\n});\n\nexport const clearGraph = () => ({\n  type: ActionTypes.CLEAR_GRAPH,\n});\n\nexport const resetGraph = () => ({\n  type: ActionTypes.RESET_GRAPH,\n});\n\nexport const startAlgorithm = () => ({\n  type: ActionTypes.START_ALGORITHM,\n});\n\nexport const endAlgorithm = () => ({\n  type: ActionTypes.END_ALGORITHM,\n});\n","// User selection modes\nexport const GraphModes = Object.freeze({\n  START: \"start\",\n  END: \"end\",\n  WALL: \"wall\",\n});\n\n// Possible node states\nexport const NodeTypes = Object.freeze({\n  DEFAULT: \"default\",\n  START: \"start\",\n  END: \"end\",\n  WALL: \"wall\",\n  TRAVERSED: \"traversed\",\n  PATH: \"path\",\n});\n","import { NodeTypes } from 'constants/graph';\nimport { CHANGE_NODE_TYPE, CLEAR_GRAPH, RESET_GRAPH } from 'constants/action-types';\n\nfunction initialState() {\n  const rows = Math.floor((window.innerHeight - 75) / 34);\n  const columns = Math.floor(window.innerWidth / 34);\n\n  const matrix = [...Array(rows)].map(x =>\n    [...Array(columns)].map(x =>\n      NodeTypes.DEFAULT\n    )\n  );\n  const currStart = {\n    row: Math.floor(rows / 2),\n    col: Math.floor(columns / 3) - 1,\n  };\n  const currEnd = {\n    row: Math.floor(rows / 2),\n    col: Math.floor(columns * 2 / 3),\n  };\n\n  matrix[currStart.row][currStart.col] = NodeTypes.START;\n  matrix[currEnd.row][currEnd.col] = NodeTypes.END;\n\n  return {\n    matrix,\n    currStart,\n    currEnd,\n  };\n};\n\nfunction reducer(state = initialState(), action) {\n  let { matrix, currStart, currEnd } = state;\n\n  switch (action.type) {\n    case CHANGE_NODE_TYPE:\n      const { node: { row, col }, nodeType } = action;\n\n      // can't overwrite start and end nodes\n      if (matrix[row][col] !== NodeTypes.START && matrix[row][col] !== NodeTypes.END) {\n        // ensure only one start and end node exist\n        if (nodeType === NodeTypes.START) {\n          if (currStart) {\n            matrix[currStart.row][currStart.col] = NodeTypes.DEFAULT;\n          }\n          currStart = { row, col };\n        } else if (nodeType === NodeTypes.END) {\n          if (currEnd) {\n            matrix[currEnd.row][currEnd.col] = NodeTypes.DEFAULT;\n          }\n          currEnd = { row, col };\n        }\n\n        matrix[row][col] = nodeType;\n      }\n\n      return {\n        matrix,\n        currStart,\n        currEnd,\n      };\n    case CLEAR_GRAPH:\n      matrix.forEach((rowArr, row, arr) => {\n        rowArr.forEach((node, col) => {\n          if (matrix[row][col] === NodeTypes.TRAVERSED || matrix[row][col] === NodeTypes.PATH) {\n            matrix[row][col] = NodeTypes.DEFAULT;\n          }\n        });\n      });\n\n      return {\n        ...state,\n        matrix\n      };\n    case RESET_GRAPH:\n      matrix.forEach((rowArr, row, arr) => {\n        rowArr.forEach((node, col) => {\n          if (matrix[row][col] !== NodeTypes.START && matrix[row][col] !== NodeTypes.END) {\n            matrix[row][col] = NodeTypes.DEFAULT;\n          }\n        });\n      });\n\n      return {\n        ...state,\n        matrix\n      };\n    default:\n      return state;\n  }\n};\n\nexport default reducer;\n","import { START_ALGORITHM, END_ALGORITHM } from 'constants/action-types';\n\nconst initialState = {\n  isRunning: false,\n};\n\nfunction reducer(state = initialState, action) {\n  switch (action.type) {\n    case START_ALGORITHM:\n      return { ...state, isRunning: true };\n    case END_ALGORITHM:\n      return {...state, isRunning: false };\n    default:\n      return state;\n  }\n}\n\nexport default reducer;\n","import { combineReducers } from 'redux';\nimport graph from './graph';\nimport algorithm from './algorithm';\n\nconst rootReducer = combineReducers({\n  graph,\n  algorithm,\n});\n\nexport default rootReducer;\n","import { createStore } from 'redux';\nimport rootReducer from 'reducers';\n\nconst store = createStore(rootReducer);\n\nexport default store;\n","import store from 'store';\nimport { changeNodeType, clearGraph, startAlgorithm, endAlgorithm } from 'actions';\nimport { NodeTypes } from 'constants/graph';\n\nfunction adjacent(node, graph) {\n  const { row, col } = node;\n  const adjacentNodes = new Set();\n\n  if (col !== graph[0].length - 1 && graph[row][col + 1] !== NodeTypes.WALL) {\n    adjacentNodes.add({ row, col: col + 1 });\n  }\n\n  if (col !== 0 && graph[row][col - 1] !== NodeTypes.WALL) {\n    adjacentNodes.add({ row, col: col - 1 });\n  }\n\n  if (row !== graph.length - 1 && graph[row + 1][col] !== NodeTypes.WALL) {\n    adjacentNodes.add({ row: row + 1, col });\n  }\n\n  if (row !== 0 && graph[row - 1][col] !== NodeTypes.WALL) {\n    adjacentNodes.add({ row: row - 1, col });\n  }\n\n  return adjacentNodes;\n}\n\nfunction minDistance(distance, Q) {\n  let minDist = Infinity;\n  let minNode;\n\n  Q.forEach(element => {\n    const { row, col } = element;\n    if (distance[row][col] < minDist) {\n      minDist = distance[row][col];\n      minNode = { row, col };\n    }\n  });\n\n  return minNode;\n}\n\nfunction sleep(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nasync function dijkstra(graph, start, end) {\n  const dispatch = store.dispatch;\n  dispatch(startAlgorithm());\n  const Q = new Set();\n  const rows = graph.length;\n  const columns = graph[0].length;\n\n  store.dispatch(clearGraph());\n\n  graph.forEach((rowArr, rowNum) => {\n    rowArr.forEach((node, colNum) => {\n      Q.add({\n        row: rowNum,\n        col: colNum\n      });\n    });\n  });\n\n  const distance = [...Array(rows)].map(x =>\n    [...Array(columns)].map(x =>\n      Infinity\n    )\n  );\n\n  const previous = [...Array(rows)].map(x =>\n    [...Array(columns)].map(x =>\n      undefined\n    )\n  );\n\n  distance[start.row][start.col] = 0;\n  let reachedEnd = false;\n\n  while (Q.size > 0 && !reachedEnd) {\n    const state = store.getState();\n    if (!state.algorithm.isRunning) {\n      break;\n    }\n\n    const u = minDistance(distance, Q);\n    // path does not exist\n    if (!u) {\n      break;\n    }\n\n    Q.forEach(element => {\n      if(element.row === u.row && element.col === u.col) {\n        Q.delete(element);\n      }\n    });\n\n    for (const v of adjacent(u, graph)) {\n      dispatch(changeNodeType(v, NodeTypes.TRAVERSED));\n\n      const altDist = distance[u.row][u.col] + 1;\n      if (altDist < distance[v.row][v.col]) {\n        distance[v.row][v.col] = altDist;\n        previous[v.row][v.col] = u;\n      }\n\n      if (v.row === end.row && v.col === end.col) {\n        reachedEnd = true;\n      }\n    }\n\n    await sleep(0);\n  }\n\n  let u = previous[end.row][end.col];\n  if (u) {\n    while (u.row !== start.row || u.col !== start.col) {\n      dispatch(changeNodeType(u, NodeTypes.PATH));\n      u = previous[u.row][u.col];\n    }\n  }\n\n  dispatch(endAlgorithm());\n}\n\nexport default dijkstra;\n","import React from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\n\nimport './styles.css';\nimport { clearGraph, resetGraph, endAlgorithm } from 'actions';\nimport { GraphModes } from 'constants/graph';\nimport dijkstra from 'algorithms/dijkstra';\n\nconst ActionsBar = ({ mode, setMode }) =>  {\n  const dispatch = useDispatch();\n  const { graph, start, end, algoRunning } = useSelector(state => ({\n    graph: state.graph.matrix,\n    start: state.graph.currStart,\n    end: state.graph.currEnd,\n    algoRunning: state.algorithm.isRunning,\n  }));\n\n  return (\n    <div className=\"actions-bar\">\n      <div className=\"mode-container\">\n        <p>Insert:</p>\n        <div className=\"mode-switcher\">\n          <div>\n            <input type=\"radio\" id=\"start-radio\" name=\"graph-mode\" onClick={() => setMode(GraphModes.START)} />\n            <label for=\"start-radio\">START</label>\n          </div>\n          <div>\n            <input type=\"radio\" id=\"end-radio\" name=\"graph-mode\" onClick={() => setMode(GraphModes.END)} />\n            <label for=\"end-radio\">END</label>\n          </div>\n          <div>\n            <input type=\"radio\" id=\"wall-radio\" name=\"graph-mode\" onClick={() => setMode(GraphModes.WALL)} defaultChecked/>\n            <label for=\"wall-radio\">WALL</label>\n          </div>\n        </div>\n      </div>\n\n      <div className=\"action-container\">\n        <button className=\"run button\" onClick={() => dijkstra(graph, start, end)} disabled={algoRunning}>Run Dijkstra's</button>\n        <button className=\"stop button\" onClick={() => dispatch(endAlgorithm())} disabled={!algoRunning}>Stop</button>\n        <button className=\"action button\" onClick={() => dispatch(clearGraph())} disabled={algoRunning}>Clear Graph</button>\n        <button className=\"action button\" onClick={() => dispatch(resetGraph())} disabled={algoRunning}>Reset Graph</button>\n      </div>\n    </div>\n  );\n};\n\nexport default ActionsBar;\n","import React from 'react';\n\nimport './styles.css';\n\nconst Node = ({ row, col, className, onClick, disabled }) => {\n  return (\n    <button className={`${className} node`} onClick={() => onClick({ row, col })} disabled={disabled} />\n  );\n};\n\nexport default Node;\n","import React, { useCallback } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\n\nimport './styles.css';\nimport { GraphModes, NodeTypes } from 'constants/graph';\nimport { changeNodeType } from 'actions';\nimport Node from 'components/Node';\n\nconst Graph = ({ graphMode }) => {\n  const dispatch = useDispatch();\n  const { matrix, algoRunning } = useSelector(state => ({\n    matrix: state.graph.matrix,\n    algoRunning: state.algorithm.isRunning,\n  }));\n\n  const handleClick = useCallback(({ row, col }) => {\n    let nodeType;\n\n    // wall toggling\n    if (graphMode === GraphModes.WALL && matrix[row][col] === NodeTypes.WALL) {\n      nodeType = NodeTypes.DEFAULT;\n    } else {\n      nodeType = graphMode;\n    }\n\n    dispatch(changeNodeType({ row, col }, nodeType));\n  }, [dispatch, graphMode, matrix]);\n\n  return (\n    <div className=\"graph\">\n      {matrix && matrix.length > 0 && matrix.map((rowArr, rowNum) => {\n        return (\n          <div>\n            {rowArr && rowArr.length > 0 && rowArr.map((value, colNum) => {\n              return (\n                <Node row={rowNum} col={colNum} className={value}  onClick={handleClick} disabled={algoRunning} />\n              );\n            })}\n          </div>\n        );\n      })}\n    </div>\n  );\n};\n\nexport default Graph;\n","import React, { useState } from 'react';\n\nimport logo from './logo.svg';\nimport './App.css';\nimport ActionsBar from 'components/ActionsBar';\nimport Graph from 'components/Graph';\nimport { GraphModes } from 'constants/graph';\n\nconst App = () => {\n  const [graphMode, setGraphMode] = useState(GraphModes.WALL);\n\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <img src={logo} className=\"App-logo\" alt=\"logo\" />\n        <b>Graph Algorithms Visualizer</b>\n      </header>\n      <ActionsBar mode={graphMode} setMode={setGraphMode}/>\n      <Graph graphMode={graphMode} />\n    </div>\n  );\n};\n\nexport default App;\n","import React from 'react';\nimport { render } from 'react-dom';\nimport { Provider } from 'react-redux';\n\nimport './index.css';\nimport App from './App';\nimport store from 'store';\n\nrender(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}